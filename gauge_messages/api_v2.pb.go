// Code generated by protoc-gen-go.
// source: api_v2.proto
// DO NOT EDIT!

package gauge_messages

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Types of log level that gauge supports
type ExecutionRequest_LogLevel int32

const (
	ExecutionRequest_INFO    ExecutionRequest_LogLevel = 0
	ExecutionRequest_DEBUG   ExecutionRequest_LogLevel = 1
	ExecutionRequest_WARNING ExecutionRequest_LogLevel = 2
	ExecutionRequest_ERROR   ExecutionRequest_LogLevel = 3
)

var ExecutionRequest_LogLevel_name = map[int32]string{
	0: "INFO",
	1: "DEBUG",
	2: "WARNING",
	3: "ERROR",
}
var ExecutionRequest_LogLevel_value = map[string]int32{
	"INFO":    0,
	"DEBUG":   1,
	"WARNING": 2,
	"ERROR":   3,
}

func (x ExecutionRequest_LogLevel) String() string {
	return proto.EnumName(ExecutionRequest_LogLevel_name, int32(x))
}
func (ExecutionRequest_LogLevel) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{0, 0} }

// Strategies for parallelization
type ExecutionRequest_Strategy int32

const (
	ExecutionRequest_LAZY  ExecutionRequest_Strategy = 0
	ExecutionRequest_EAGER ExecutionRequest_Strategy = 1
)

var ExecutionRequest_Strategy_name = map[int32]string{
	0: "LAZY",
	1: "EAGER",
}
var ExecutionRequest_Strategy_value = map[string]int32{
	"LAZY":  0,
	"EAGER": 1,
}

func (x ExecutionRequest_Strategy) String() string {
	return proto.EnumName(ExecutionRequest_Strategy_name, int32(x))
}
func (ExecutionRequest_Strategy) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{0, 1} }

// Specifies the execution status
type Result_Status int32

const (
	Result_PASSED  Result_Status = 0
	Result_FAILED  Result_Status = 1
	Result_SKIPPED Result_Status = 2
)

var Result_Status_name = map[int32]string{
	0: "PASSED",
	1: "FAILED",
	2: "SKIPPED",
}
var Result_Status_value = map[string]int32{
	"PASSED":  0,
	"FAILED":  1,
	"SKIPPED": 2,
}

func (x Result_Status) String() string {
	return proto.EnumName(Result_Status_name, int32(x))
}
func (Result_Status) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{1, 0} }

// Types of Execution respone
type ExecutionResponse_Type int32

const (
	ExecutionResponse_SuiteStart    ExecutionResponse_Type = 0
	ExecutionResponse_SpecStart     ExecutionResponse_Type = 1
	ExecutionResponse_ScenarioStart ExecutionResponse_Type = 2
	ExecutionResponse_ScenarioEnd   ExecutionResponse_Type = 3
	ExecutionResponse_SpecEnd       ExecutionResponse_Type = 4
	ExecutionResponse_SuiteEnd      ExecutionResponse_Type = 5
	ExecutionResponse_ErrorResult   ExecutionResponse_Type = 6
)

var ExecutionResponse_Type_name = map[int32]string{
	0: "SuiteStart",
	1: "SpecStart",
	2: "ScenarioStart",
	3: "ScenarioEnd",
	4: "SpecEnd",
	5: "SuiteEnd",
	6: "ErrorResult",
}
var ExecutionResponse_Type_value = map[string]int32{
	"SuiteStart":    0,
	"SpecStart":     1,
	"ScenarioStart": 2,
	"ScenarioEnd":   3,
	"SpecEnd":       4,
	"SuiteEnd":      5,
	"ErrorResult":   6,
}

func (x ExecutionResponse_Type) String() string {
	return proto.EnumName(ExecutionResponse_Type_name, int32(x))
}
func (ExecutionResponse_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{2, 0} }

// ExecutionRequest defines the structure of requests that the API's consumers can send to request execution of specs/scenarios
type ExecutionRequest struct {
	// Each ExecutionRequest can ask to execute multiple spec files or multiple scenarios in a spec or a directory or all
	Specs []string `protobuf:"bytes,1,rep,name=specs" json:"specs,omitempty"`
	// Tag expression to filter specs and scenarios during execution. Default: ""
	Tags string `protobuf:"bytes,2,opt,name=tags" json:"tags,omitempty"`
	// The working directory for gauge.
	WorkingDir string `protobuf:"bytes,3,opt,name=workingDir" json:"workingDir,omitempty"`
	// Environment to choose for gauge.
	Env      string                    `protobuf:"bytes,4,opt,name=env" json:"env,omitempty"`
	LogLevel ExecutionRequest_LogLevel `protobuf:"varint,5,opt,name=logLevel,enum=gauge.messages.ExecutionRequest_LogLevel" json:"logLevel,omitempty"`
	// Whether to run gauge in parallel mode.
	IsParallel bool `protobuf:"varint,6,opt,name=isParallel" json:"isParallel,omitempty"`
	// If isParallel is true, this specifies how many parallel streams to run.
	ParallelStreams int32 `protobuf:"varint,7,opt,name=parallelStreams" json:"parallelStreams,omitempty"`
	// If true, sorts execution of specifications alphabetically
	Sort     bool                      `protobuf:"varint,8,opt,name=sort" json:"sort,omitempty"`
	Strategy ExecutionRequest_Strategy `protobuf:"varint,9,opt,name=strategy,enum=gauge.messages.ExecutionRequest_Strategy" json:"strategy,omitempty"`
	// Specify against which rows of datatable the scenarios should be executed
	TableRows string `protobuf:"bytes,10,opt,name=tableRows" json:"tableRows,omitempty"`
	// Signals Gauge that the execution is being debugged, usually via an identifier
	Debug bool `protobuf:"varint,11,opt,name=debug" json:"debug,omitempty"`
}

func (m *ExecutionRequest) Reset()                    { *m = ExecutionRequest{} }
func (m *ExecutionRequest) String() string            { return proto.CompactTextString(m) }
func (*ExecutionRequest) ProtoMessage()               {}
func (*ExecutionRequest) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

func (m *ExecutionRequest) GetSpecs() []string {
	if m != nil {
		return m.Specs
	}
	return nil
}

func (m *ExecutionRequest) GetTags() string {
	if m != nil {
		return m.Tags
	}
	return ""
}

func (m *ExecutionRequest) GetWorkingDir() string {
	if m != nil {
		return m.WorkingDir
	}
	return ""
}

func (m *ExecutionRequest) GetEnv() string {
	if m != nil {
		return m.Env
	}
	return ""
}

func (m *ExecutionRequest) GetLogLevel() ExecutionRequest_LogLevel {
	if m != nil {
		return m.LogLevel
	}
	return ExecutionRequest_INFO
}

func (m *ExecutionRequest) GetIsParallel() bool {
	if m != nil {
		return m.IsParallel
	}
	return false
}

func (m *ExecutionRequest) GetParallelStreams() int32 {
	if m != nil {
		return m.ParallelStreams
	}
	return 0
}

func (m *ExecutionRequest) GetSort() bool {
	if m != nil {
		return m.Sort
	}
	return false
}

func (m *ExecutionRequest) GetStrategy() ExecutionRequest_Strategy {
	if m != nil {
		return m.Strategy
	}
	return ExecutionRequest_LAZY
}

func (m *ExecutionRequest) GetTableRows() string {
	if m != nil {
		return m.TableRows
	}
	return ""
}

func (m *ExecutionRequest) GetDebug() bool {
	if m != nil {
		return m.Debug
	}
	return false
}

type Result struct {
	Status Result_Status `protobuf:"varint,1,opt,name=status,enum=gauge.messages.Result_Status" json:"status,omitempty"`
	// Contains the Execution errors and its details
	Errors []*Result_ExecutionError `protobuf:"bytes,2,rep,name=errors" json:"errors,omitempty"`
	// Specifies the execution time
	ExecutionTime int64 `protobuf:"varint,3,opt,name=executionTime" json:"executionTime,omitempty"`
	// Contains the console output messages
	Stdout string `protobuf:"bytes,4,opt,name=stdout" json:"stdout,omitempty"`
	// Holds the before hook failure
	BeforeHookFailure *Result_ExecutionError `protobuf:"bytes,5,opt,name=beforeHookFailure" json:"beforeHookFailure,omitempty"`
	// Holds the after hook failure
	AfterHookFailure *Result_ExecutionError `protobuf:"bytes,6,opt,name=afterHookFailure" json:"afterHookFailure,omitempty"`
	// Holds the table row number (starting with 1) against which the scenario was executed.
	// This field is populated only for data table driven scenarios.
	TableRowNumber int64 `protobuf:"varint,7,opt,name=tableRowNumber" json:"tableRowNumber,omitempty"`
}

func (m *Result) Reset()                    { *m = Result{} }
func (m *Result) String() string            { return proto.CompactTextString(m) }
func (*Result) ProtoMessage()               {}
func (*Result) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{1} }

func (m *Result) GetStatus() Result_Status {
	if m != nil {
		return m.Status
	}
	return Result_PASSED
}

func (m *Result) GetErrors() []*Result_ExecutionError {
	if m != nil {
		return m.Errors
	}
	return nil
}

func (m *Result) GetExecutionTime() int64 {
	if m != nil {
		return m.ExecutionTime
	}
	return 0
}

func (m *Result) GetStdout() string {
	if m != nil {
		return m.Stdout
	}
	return ""
}

func (m *Result) GetBeforeHookFailure() *Result_ExecutionError {
	if m != nil {
		return m.BeforeHookFailure
	}
	return nil
}

func (m *Result) GetAfterHookFailure() *Result_ExecutionError {
	if m != nil {
		return m.AfterHookFailure
	}
	return nil
}

func (m *Result) GetTableRowNumber() int64 {
	if m != nil {
		return m.TableRowNumber
	}
	return 0
}

// ExecutionError represents the failure during execution along with details of failure
type Result_ExecutionError struct {
	// Error message from the failure
	ErrorMessage string `protobuf:"bytes,1,opt,name=errorMessage" json:"errorMessage,omitempty"`
	// Stacktrace from the failure
	StackTrace string `protobuf:"bytes,2,opt,name=stackTrace" json:"stackTrace,omitempty"`
	// Byte array holding the screenshot taken at the time of failure.
	Screenshot []byte `protobuf:"bytes,3,opt,name=screenshot,proto3" json:"screenshot,omitempty"`
}

func (m *Result_ExecutionError) Reset()                    { *m = Result_ExecutionError{} }
func (m *Result_ExecutionError) String() string            { return proto.CompactTextString(m) }
func (*Result_ExecutionError) ProtoMessage()               {}
func (*Result_ExecutionError) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{1, 0} }

func (m *Result_ExecutionError) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

func (m *Result_ExecutionError) GetStackTrace() string {
	if m != nil {
		return m.StackTrace
	}
	return ""
}

func (m *Result_ExecutionError) GetScreenshot() []byte {
	if m != nil {
		return m.Screenshot
	}
	return nil
}

// ExecutionResponse defines the structure of response for ExecutionRequest message
type ExecutionResponse struct {
	// Response type
	Type ExecutionResponse_Type `protobuf:"varint,1,opt,name=type,enum=gauge.messages.ExecutionResponse_Type" json:"type,omitempty"`
	// An identifier for the current execution result. This field is populated only for spec/scenario result.
	// For spec, the value will be the filename.
	// For scenario, the value will be filename:scenario_heading_line_num.
	ID string `protobuf:"bytes,2,opt,name=ID" json:"ID,omitempty"`
	// Contains all the result details. This field is populated only for ScenarioStart, ScenaioEnd, SpecEnd, SuiteEnd, ErrorResult
	Result *Result `protobuf:"bytes,3,opt,name=result" json:"result,omitempty"`
	// Contains the processId of the language runner used for execution.
	RunnerProcessId int32 `protobuf:"varint,4,opt,name=RunnerProcessId" json:"RunnerProcessId,omitempty"`
}

func (m *ExecutionResponse) Reset()                    { *m = ExecutionResponse{} }
func (m *ExecutionResponse) String() string            { return proto.CompactTextString(m) }
func (*ExecutionResponse) ProtoMessage()               {}
func (*ExecutionResponse) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{2} }

func (m *ExecutionResponse) GetType() ExecutionResponse_Type {
	if m != nil {
		return m.Type
	}
	return ExecutionResponse_SuiteStart
}

func (m *ExecutionResponse) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *ExecutionResponse) GetResult() *Result {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *ExecutionResponse) GetRunnerProcessId() int32 {
	if m != nil {
		return m.RunnerProcessId
	}
	return 0
}

func init() {
	proto.RegisterType((*ExecutionRequest)(nil), "gauge.messages.ExecutionRequest")
	proto.RegisterType((*Result)(nil), "gauge.messages.Result")
	proto.RegisterType((*Result_ExecutionError)(nil), "gauge.messages.Result.ExecutionError")
	proto.RegisterType((*ExecutionResponse)(nil), "gauge.messages.ExecutionResponse")
	proto.RegisterEnum("gauge.messages.ExecutionRequest_LogLevel", ExecutionRequest_LogLevel_name, ExecutionRequest_LogLevel_value)
	proto.RegisterEnum("gauge.messages.ExecutionRequest_Strategy", ExecutionRequest_Strategy_name, ExecutionRequest_Strategy_value)
	proto.RegisterEnum("gauge.messages.Result_Status", Result_Status_name, Result_Status_value)
	proto.RegisterEnum("gauge.messages.ExecutionResponse_Type", ExecutionResponse_Type_name, ExecutionResponse_Type_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Execution service

type ExecutionClient interface {
	// Bind RPC method
	Execute(ctx context.Context, in *ExecutionRequest, opts ...grpc.CallOption) (Execution_ExecuteClient, error)
}

type executionClient struct {
	cc *grpc.ClientConn
}

func NewExecutionClient(cc *grpc.ClientConn) ExecutionClient {
	return &executionClient{cc}
}

func (c *executionClient) Execute(ctx context.Context, in *ExecutionRequest, opts ...grpc.CallOption) (Execution_ExecuteClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Execution_serviceDesc.Streams[0], c.cc, "/gauge.messages.Execution/execute", opts...)
	if err != nil {
		return nil, err
	}
	x := &executionExecuteClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Execution_ExecuteClient interface {
	Recv() (*ExecutionResponse, error)
	grpc.ClientStream
}

type executionExecuteClient struct {
	grpc.ClientStream
}

func (x *executionExecuteClient) Recv() (*ExecutionResponse, error) {
	m := new(ExecutionResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Execution service

type ExecutionServer interface {
	// Bind RPC method
	Execute(*ExecutionRequest, Execution_ExecuteServer) error
}

func RegisterExecutionServer(s *grpc.Server, srv ExecutionServer) {
	s.RegisterService(&_Execution_serviceDesc, srv)
}

func _Execution_Execute_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ExecutionRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ExecutionServer).Execute(m, &executionExecuteServer{stream})
}

type Execution_ExecuteServer interface {
	Send(*ExecutionResponse) error
	grpc.ServerStream
}

type executionExecuteServer struct {
	grpc.ServerStream
}

func (x *executionExecuteServer) Send(m *ExecutionResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _Execution_serviceDesc = grpc.ServiceDesc{
	ServiceName: "gauge.messages.Execution",
	HandlerType: (*ExecutionServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "execute",
			Handler:       _Execution_Execute_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "api_v2.proto",
}

func init() { proto.RegisterFile("api_v2.proto", fileDescriptor1) }

var fileDescriptor1 = []byte{
	// 733 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x94, 0x54, 0x5f, 0x6f, 0x1a, 0x47,
	0x10, 0x37, 0x1c, 0x9c, 0x61, 0xc0, 0xf8, 0x58, 0x55, 0xd6, 0xc9, 0xea, 0x1f, 0xf7, 0xd4, 0x5a,
	0xee, 0x43, 0x51, 0x45, 0x55, 0x55, 0xaa, 0xd4, 0x07, 0x2c, 0xce, 0x14, 0x95, 0x62, 0xba, 0x47,
	0x55, 0x25, 0x2f, 0xd6, 0x01, 0xe3, 0xcb, 0xc9, 0x70, 0x4b, 0x76, 0xf7, 0xec, 0xf8, 0x2b, 0xe5,
	0x29, 0xf9, 0x56, 0xf9, 0x18, 0xd9, 0xdd, 0x3b, 0x08, 0xe0, 0x24, 0x76, 0xde, 0x66, 0x7e, 0x3b,
	0xbf, 0xd9, 0x99, 0xd9, 0xdf, 0x2c, 0xd4, 0xc3, 0x65, 0x7c, 0x75, 0xdb, 0x6e, 0x2d, 0x39, 0x93,
	0x8c, 0x34, 0xa2, 0x30, 0x8d, 0xb0, 0xb5, 0x40, 0x21, 0xc2, 0x08, 0x85, 0xf7, 0xce, 0x02, 0xc7,
	0x7f, 0x85, 0xd3, 0x54, 0xc6, 0x2c, 0xa1, 0xf8, 0x32, 0x45, 0x21, 0xc9, 0x57, 0x50, 0x16, 0x4b,
	0x9c, 0x0a, 0xb7, 0x70, 0x62, 0x9d, 0x55, 0x69, 0xe6, 0x10, 0x02, 0x25, 0x19, 0x46, 0xc2, 0x2d,
	0x9e, 0x14, 0x14, 0x68, 0x6c, 0xf2, 0x2d, 0xc0, 0x1d, 0xe3, 0x37, 0x71, 0x12, 0x75, 0x63, 0xee,
	0x5a, 0xe6, 0x64, 0x03, 0x21, 0x0e, 0x58, 0x98, 0xdc, 0xba, 0x25, 0x73, 0xa0, 0x4d, 0xe2, 0x43,
	0x65, 0xce, 0xa2, 0x01, 0xde, 0xe2, 0xdc, 0x2d, 0x2b, 0xb8, 0xd1, 0xfe, 0xa9, 0xb5, 0x5d, 0x53,
	0x6b, 0xb7, 0x9e, 0xd6, 0x20, 0x27, 0xd0, 0x35, 0x55, 0x5f, 0x1c, 0x8b, 0x51, 0xc8, 0xc3, 0xf9,
	0x5c, 0x25, 0xb2, 0x55, 0xa2, 0x0a, 0xdd, 0x40, 0xc8, 0x19, 0x1c, 0x2e, 0x73, 0x3b, 0x90, 0x1c,
	0xc3, 0x85, 0x70, 0xf7, 0x55, 0x50, 0x99, 0xee, 0xc2, 0xba, 0x2d, 0xc1, 0xb8, 0x74, 0x2b, 0x26,
	0x87, 0xb1, 0x75, 0x91, 0x42, 0xf2, 0x50, 0x62, 0x74, 0xef, 0x56, 0x9f, 0x58, 0x64, 0x90, 0x13,
	0xe8, 0x9a, 0x4a, 0xbe, 0x86, 0xaa, 0x0c, 0x27, 0x73, 0xa4, 0xec, 0x4e, 0xb8, 0x60, 0x66, 0xf0,
	0x01, 0xd0, 0x53, 0x9e, 0xe1, 0x24, 0x8d, 0xdc, 0x9a, 0xb9, 0x39, 0x73, 0xbc, 0xdf, 0xa1, 0xb2,
	0x6a, 0x97, 0x54, 0xa0, 0xd4, 0x1f, 0x5e, 0x5c, 0x3a, 0x7b, 0xa4, 0x0a, 0xe5, 0xae, 0x7f, 0xfe,
	0x5f, 0xcf, 0x29, 0x90, 0x1a, 0xec, 0xff, 0xdf, 0xa1, 0xc3, 0xfe, 0xb0, 0xe7, 0x14, 0x35, 0xee,
	0x53, 0x7a, 0x49, 0x1d, 0xcb, 0xfb, 0x0e, 0x2a, 0xab, 0x12, 0x34, 0x71, 0xd0, 0x79, 0xfe, 0x2c,
	0x23, 0xfa, 0x9d, 0x9e, 0x4f, 0x9d, 0x82, 0xf7, 0xb6, 0x04, 0x36, 0x45, 0x91, 0xce, 0x25, 0xf9,
	0x0d, 0x6c, 0x21, 0x43, 0x99, 0xea, 0x17, 0xd6, 0xdd, 0x7d, 0xb3, 0xdb, 0x5d, 0x16, 0xa7, 0x7a,
	0xd2, 0x41, 0x34, 0x0f, 0x26, 0x7f, 0x82, 0x8d, 0x9c, 0x33, 0xae, 0x35, 0x60, 0x9d, 0xd5, 0xda,
	0x3f, 0x7e, 0x82, 0xb6, 0x9e, 0x8d, 0xaf, 0xa3, 0x69, 0x4e, 0x22, 0x3f, 0xc0, 0x01, 0xae, 0x4e,
	0xc6, 0xf1, 0x02, 0x8d, 0x5e, 0x2c, 0xba, 0x0d, 0x92, 0x23, 0x5d, 0xdb, 0x8c, 0xa5, 0x32, 0x57,
	0x4d, 0xee, 0x91, 0x00, 0x9a, 0x13, 0xbc, 0x66, 0x1c, 0xff, 0x62, 0xec, 0xe6, 0x22, 0x8c, 0xe7,
	0x29, 0x47, 0xa3, 0xa0, 0x27, 0xd7, 0xf1, 0x90, 0x4f, 0xfe, 0x05, 0x27, 0xbc, 0x96, 0xc8, 0x37,
	0x73, 0xda, 0x5f, 0x92, 0xf3, 0x01, 0x9d, 0x9c, 0x42, 0x63, 0xf5, 0xc6, 0xc3, 0x74, 0x31, 0x41,
	0x6e, 0x84, 0x67, 0xd1, 0x1d, 0xf4, 0x58, 0x42, 0x63, 0x3b, 0x17, 0xf1, 0xa0, 0x6e, 0x26, 0xf5,
	0x4f, 0x76, 0xa5, 0x79, 0x9b, 0x2a, 0xdd, 0xc2, 0xb4, 0xee, 0xd5, 0x63, 0x4c, 0x6f, 0xc6, 0x3c,
	0x9c, 0x62, 0xbe, 0x8a, 0x1b, 0x88, 0x39, 0x9f, 0x72, 0xc4, 0x44, 0xbc, 0x60, 0xd2, 0x0c, 0xb8,
	0x4e, 0x37, 0x10, 0xef, 0x67, 0xb0, 0xb3, 0x47, 0x25, 0x00, 0xf6, 0xa8, 0x13, 0x04, 0x7e, 0x57,
	0xa9, 0x44, 0xd9, 0x17, 0x9d, 0xfe, 0x40, 0xd9, 0x46, 0x5f, 0xc1, 0xdf, 0xfd, 0xd1, 0x48, 0x39,
	0x45, 0xef, 0x4d, 0x11, 0x9a, 0x1b, 0x4a, 0x17, 0x4b, 0x96, 0x08, 0x24, 0x7f, 0xa8, 0x9f, 0xe0,
	0x7e, 0x89, 0xb9, 0x78, 0x4e, 0x3f, 0xb3, 0x1a, 0x19, 0xa1, 0x35, 0x56, 0xd1, 0xd4, 0x70, 0x48,
	0x03, 0x8a, 0xfd, 0x6e, 0x5e, 0xb8, 0xb2, 0x48, 0x0b, 0x6c, 0x6e, 0x26, 0x6b, 0x8a, 0xad, 0xb5,
	0x8f, 0x3e, 0x3e, 0x77, 0x9a, 0x47, 0xe9, 0xc5, 0xa6, 0x69, 0x92, 0x20, 0x1f, 0x71, 0x36, 0x55,
	0x31, 0xfd, 0x99, 0xd1, 0x89, 0x5a, 0xec, 0x1d, 0xd8, 0x4b, 0xa1, 0x34, 0xce, 0x6e, 0x84, 0x20,
	0x8d, 0x25, 0xaa, 0xbe, 0xb9, 0x54, 0xcd, 0x1e, 0x40, 0x35, 0x50, 0x1f, 0x5a, 0xe6, 0x16, 0x48,
	0x13, 0x0e, 0x82, 0x29, 0x26, 0x21, 0x8f, 0x59, 0x06, 0x15, 0xc9, 0x21, 0xd4, 0x56, 0x90, 0x9f,
	0xcc, 0x1c, 0xcb, 0xcc, 0x44, 0x51, 0xb4, 0x53, 0x22, 0x75, 0xb5, 0x68, 0x3a, 0x9f, 0xf6, 0xca,
	0x3a, 0x36, 0x53, 0x82, 0x29, 0xcf, 0xb1, 0xdb, 0x57, 0x50, 0x5d, 0x0f, 0x80, 0x50, 0xd8, 0xcf,
	0xd4, 0x8d, 0xe4, 0xe4, 0xb1, 0x1f, 0xe4, 0xf8, 0xfb, 0x47, 0x07, 0xe9, 0xed, 0xfd, 0x52, 0x38,
	0x6f, 0xbe, 0x2e, 0x36, 0x7a, 0x26, 0x30, 0x17, 0x85, 0x98, 0xd8, 0xe6, 0x73, 0xff, 0xf5, 0x7d,
	0x00, 0x00, 0x00, 0xff, 0xff, 0xc5, 0xaf, 0x74, 0x09, 0xec, 0x05, 0x00, 0x00,
}
