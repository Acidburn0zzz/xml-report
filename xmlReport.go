// Copyright 2015 ThoughtWorks, Inc.

// This file is part of getgauge/xml-report.

// getgauge/xml-report is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// getgauge/xml-report is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with getgauge/xml-report.  If not, see <http://www.gnu.org/licenses/>.

package main

import (
	"encoding/xml"
	"errors"
	"fmt"
	"github.com/getgauge/common"
	"github.com/getgauge/xml-report/gauge_messages"
	"github.com/getgauge/xml-report/listener"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"time"
)

const (
	defaultReportsDir           = "reports"
	gaugeReportsDirEnvName      = "gauge_reports_dir" // directory where reports are generated by plugins
	SETUP_ACTION                = "setup"
	EXECUTION_ACTION            = "execution"
	GAUGE_HOST                  = "localhost"
	GAUGE_PORT_ENV              = "plugin_connection_port"
	PLUGIN_ACTION_ENV           = "xml-report_action"
	xmlReport                   = "xml-report"
	overwriteReportsEnvProperty = "overwrite_reports"
	resultFile                  = "result.xml"
	timeFormat                  = "2013-05-24T10:23:58"
	hostname                    = "HOSTNAME"
)

var projectRoot string
var pluginDir string

// JUnitTestSuites is a collection of JUnit test suites.
type JUnitTestSuites struct {
	XMLName xml.Name `xml:"testsuites"`
	Suites  []JUnitTestSuite
}

// JUnitTestSuite is a single JUnit test suite which may contain many
// testcases.
type JUnitTestSuite struct {
	XMLName      xml.Name        `xml:"testsuite"`
	Id           int             `xml:"id,attr"`
	Tests        int             `xml:"tests,attr"`
	Failures     int             `xml:"failures,attr"`
	Package      string          `xml:"package,attr"`
	Time         string          `xml:"time,attr"`
	Timestamp    string          `xml:"timestamp,attr"`
	Name         string          `xml:"name,attr"`
	Errors       int             `xml:"errors,attr"`
	Hostname     string          `xml:"hostname,attr"`
	Properties   []JUnitProperty `xml:"properties>property,omitempty"`
	TestCases    []JUnitTestCase
	SystemOutput SystemOut
	SystemError  SystemErr
}

// JUnitTestCase is a single test case with its result.
type JUnitTestCase struct {
	XMLName     xml.Name          `xml:"testcase"`
	Classname   string            `xml:"classname,attr"`
	Name        string            `xml:"name,attr"`
	Time        string            `xml:"time,attr"`
	SkipMessage *JUnitSkipMessage `xml:"skipped,omitempty"`
	Failure     *JUnitFailure     `xml:"failure,omitempty"`
}

type SystemOut struct {
	XMLName  xml.Name `xml:"system-out"`
	Contents string   `xml:",chardata"`
}

type SystemErr struct {
	XMLName  xml.Name `xml:"system-err"`
	Contents string   `xml:",chardata"`
}

// JUnitSkipMessage contains the reason why a testcase was skipped.
type JUnitSkipMessage struct {
	Message string `xml:"message,attr"`
}

// JUnitProperty represents a key/value pair used to define properties.
type JUnitProperty struct {
	Name  string `xml:"name,attr"`
	Value string `xml:"value,attr"`
}

// JUnitFailure contains data related to a failed test.
type JUnitFailure struct {
	Message  string `xml:"message,attr"`
	Type     string `xml:"type,attr"`
	Contents string `xml:",chardata"`
}

func addDefaultPropertiesToProject() {
	defaultPropertiesFile := getDefaultPropertiesFile()

	reportsDirProperty := &(common.Property{
		Comment:      "The path to the gauge reports directory. Should be either relative to the project directory or an absolute path",
		Name:         gaugeReportsDirEnvName,
		DefaultValue: defaultReportsDir})

	overwriteReportProperty := &(common.Property{
		Comment:      "Set as false if gauge reports should not be overwritten on each execution. A new time-stamped directory will be created on each execution.",
		Name:         overwriteReportsEnvProperty,
		DefaultValue: "true"})

	if !common.FileExists(defaultPropertiesFile) {
		fmt.Printf("Failed to setup html report plugin in project. Default properties file does not exist at %s. \n", defaultPropertiesFile)
		return
	}
	if err := common.AppendProperties(defaultPropertiesFile, reportsDirProperty, overwriteReportProperty); err != nil {
		fmt.Printf("Failed to setup html report plugin in project: %s \n", err)
		return
	}
	fmt.Println("Succesfully added configurations for xml-report to env/default/default.properties")
}

func getDefaultPropertiesFile() string {
	return filepath.Join(projectRoot, "env", "default", "default.properties")
}

func createReport(suiteResult *gauge_messages.SuiteExecutionResult) {
	dir := createReportsDirectory()
	bytes, err := getXmlContent(suiteResult)
	if err != nil {
		fmt.Printf("Report generation failed: %s \n", err)
		os.Exit(1)
	}
	err = writeResultFile(dir, bytes)
	if err != nil {
		fmt.Printf("Report generation failed: %s \n", err)
		os.Exit(1)
	}
	fmt.Printf("Sucessfully generated xml-report to => %s\n", dir)
}

func writeResultFile(reportDir string, bytes []byte) error {
	resultPath := filepath.Join(reportDir, resultFile)
	err := ioutil.WriteFile(resultPath, bytes, common.NewFilePermissions)
	if err != nil {
		return errors.New(fmt.Sprintf("Failed to copy file: %s %s\n", resultFile, err))
	}
	return nil
}

func getXmlContent(executionSuiteResult *gauge_messages.SuiteExecutionResult) ([]byte, error) {
	suiteResult := executionSuiteResult.GetSuiteResult()
	suites := JUnitTestSuites{}
	count := 0
	for _, result := range suiteResult.GetSpecResults() {
		count += 1
		hostName, err := os.Hostname()
		if err != nil {
			hostName = hostname
		}
		now := time.Now()
		formattedNow := fmt.Sprintf("%d-%02d-%02dT%02d:%02d:%02d",
			now.Year(), now.Month(), now.Day(),
			now.Hour(), now.Minute(), now.Second())
		ts := JUnitTestSuite{
			Id:           int(count),
			Tests:        int(result.GetScenarioCount()),
			Failures:     int(result.GetScenarioFailedCount()),
			Time:         formatTime(int(result.GetExecutionTime())),
			Timestamp:    formattedNow,
			Name:         result.GetProtoSpec().GetSpecHeading(),
			Errors:       0,
			Hostname:     hostName,
			Package:      result.GetProtoSpec().GetFileName(),
			Properties:   []JUnitProperty{},
			TestCases:    []JUnitTestCase{},
			SystemOutput: SystemOut{},
			SystemError:  SystemErr{},
		}
		for _, test := range result.GetProtoSpec().GetItems() {
			if test.GetItemType() == gauge_messages.ProtoItem_Scenario {
				testCase := JUnitTestCase{
					Classname: result.GetProtoSpec().GetSpecHeading(),
					Name:      test.GetScenario().GetScenarioHeading(),
					Time:      formatTime(int(test.GetScenario().GetExecutionTime())),
					Failure:   nil,
				}
				if test.GetScenario().GetFailed() {
					testCase.Failure = &JUnitFailure{
						Message:  "Failed",
						Type:     "",
						Contents: "",
					}
				}
				ts.TestCases = append(ts.TestCases, testCase)
			}
		}
		suites.Suites = append(suites.Suites, ts)
	}
	bytes, err := xml.MarshalIndent(suites, "", "\t")
	if err != nil {
		return nil, err
	}
	return bytes, nil
}

func createExecutionReport() {
	os.Chdir(projectRoot)
	listener, err := listener.NewGaugeListener(GAUGE_HOST, os.Getenv(GAUGE_PORT_ENV))
	if err != nil {
		fmt.Println("Could not create the gauge listener")
		os.Exit(1)
	}
	listener.OnSuiteResult(createReport)
	listener.Start()
}

func findPluginAndProjectRoot() {
	projectRoot = os.Getenv(common.GaugeProjectRootEnv)
	if projectRoot == "" {
		fmt.Printf("Environment variable '%s' is not set. \n", common.GaugeProjectRootEnv)
		os.Exit(1)
	}
	var err error
	pluginDir, err = os.Getwd()
	if err != nil {
		fmt.Printf("Error finding current working directory: %s \n", err)
		os.Exit(1)
	}
}

func createReportsDirectory() string {
	reportsDir, err := filepath.Abs(os.Getenv(gaugeReportsDirEnvName))
	if reportsDir == "" || err != nil {
		reportsDir = defaultReportsDir
	}
	currentReportDir := filepath.Join(reportsDir, xmlReport, getNameGen().randomName())
	createDirectory(currentReportDir)
	return currentReportDir
}

func createDirectory(dir string) {
	if common.DirExists(dir) {
		return
	}
	if err := os.MkdirAll(dir, common.NewDirectoryPermissions); err != nil {
		fmt.Printf("Failed to create directory %s: %s\n", defaultReportsDir, err)
		os.Exit(1)
	}
}

func getNameGen() nameGenerator {
	if shouldOverwriteReports() {
		return emptyNameGenerator{}
	}
	return timeStampedNameGenerator{}
}

type nameGenerator interface {
	randomName() string
}
type timeStampedNameGenerator struct{}

func (T timeStampedNameGenerator) randomName() string {
	return time.Now().Format(timeFormat)
}

type emptyNameGenerator struct{}

func (T emptyNameGenerator) randomName() string {
	return ""
}

func shouldOverwriteReports() bool {
	envValue := os.Getenv(overwriteReportsEnvProperty)
	if strings.ToLower(envValue) == "true" {
		return true
	}
	return false
}

func formatTime(time int) string {
	return fmt.Sprintf("%.3f", float64(time)/1000.0)
}
